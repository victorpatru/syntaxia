{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Analyze Existing Codebase and Project Structure",
        "description": "Perform a comprehensive analysis of the current codebase to identify implemented components, technology stack, and architectural patterns.",
        "details": "Use Glob to list all files (e.g., **/*.ts, **/*.tsx, **/*.json, **/README.md). Use Grep to search for existing implementations of session setup, voice agent, Convex backend, and content packs. Read package.json, README.md, and main entry points to confirm frameworks (TanStack Start, Convex, Node/TypeScript) and existing modules. Document findings for reference in subsequent tasks.",
        "testStrategy": "Verify that all relevant files and modules are identified and catalogued. Ensure documentation accurately reflects the current state of implementation.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Enumerate and Catalog Project Files",
            "description": "Use Glob patterns to list all relevant files in the codebase, including TypeScript, JSON, and documentation files, to establish a comprehensive inventory.",
            "dependencies": [],
            "details": "Execute Glob queries such as **/*.ts, **/*.tsx, **/*.json, and **/README.md to identify all source, configuration, and documentation files. Organize results by file type and directory structure.\n<info added on 2025-08-10T19:30:41.080Z>\nImplementation plan for 1.1 Enumerate and Catalog Project Files:\n\n- Scope\n  - Target directories: apps/app, packages/backend/convex, packages/ui, tooling, root configs.\n- Method\n  - Enumerate files with glob patterns: **/*.ts, **/*.tsx, **/*.json, **/README.md.\n  - Prioritize entry points: apps/app/src/router.tsx, apps/app/src/routes/**, packages/backend/convex/**, packages/ui/src/**.\n  - Capture top-level package.json files for workspace and each package to confirm stack and scripts.\n- Outputs\n  - Create a structured inventory grouped by workspace: App (TanStack Start), Backend (Convex), UI package.\n  - Note special files: app.config.ts, routeTree.gen.ts (don’t edit), convex config/schema, ui globals.css.\n- Verification\n  - Cross-check counts between glob listings and manual spot checks.\n- Next\n  - Feed inventory into 1.2 (identify key implemented components) via targeted searches (Convex queries/mutations, TanStack routes, ElevenLabs SDK usage).\n</info added on 2025-08-10T19:30:41.080Z>\n<info added on 2025-08-10T19:33:55.945Z>\nFile inventory (grouped) — 2025-08-10\n\nApp (TanStack Start)\n- TS/TSX\n  - apps/app/src/router.tsx\n  - apps/app/src/routes/__root.tsx\n  - apps/app/src/routes/index.tsx\n  - apps/app/src/routes/login.tsx\n  - apps/app/src/routes/_authed/route.tsx\n  - apps/app/src/routes/_authed/dashboard.tsx\n  - apps/app/src/routeTree.gen.ts (generated, do not edit)\n  - apps/app/src/server.ts\n  - apps/app/vite.config.ts\n- JSON/Config\n  - apps/app/package.json\n  - apps/app/tsconfig.json\n  - apps/app/components.json\n\nBackend (Convex)\n- TS\n  - packages/backend/convex/auth.ts\n  - packages/backend/convex/auth.config.ts\n  - packages/backend/convex/convex.config.ts\n  - packages/backend/convex/env.ts\n  - packages/backend/convex/http.ts\n  - packages/backend/convex/init.ts\n  - packages/backend/convex/schema.ts\n  - packages/backend/convex/subscriptions.ts\n  - packages/backend/convex/users.ts\n  - packages/backend/convex/utils/validators.ts\n  - packages/backend/convex/web.ts\n- Generated TS\n  - packages/backend/convex/_generated/api.d.ts\n  - packages/backend/convex/_generated/dataModel.d.ts\n  - packages/backend/convex/_generated/server.d.ts\n- JSON/Docs\n  - packages/backend/package.json\n  - packages/backend/convex/tsconfig.json\n  - packages/backend/convex/README.md\n\nUI Library (@syntaxia/ui)\n- TS/TSX\n  - packages/ui/src/hooks/use-mobile.ts\n  - packages/ui/src/utils/index.ts\n  - packages/ui/src/utils/use-double-check.ts\n  - packages/ui/src/components/* (40+ components including button, input, table, sidebar, app-sidebar, etc.)\n- JSON/Config\n  - packages/ui/package.json\n  - packages/ui/tsconfig.json\n  - packages/ui/components.json\n\nLogger Package\n- TS\n  - packages/logger/src/index.ts\n- JSON/Config\n  - packages/logger/package.json\n  - packages/logger/tsconfig.json\n\nTooling & Root\n- JSON/Config\n  - package.json\n  - tsconfig.json\n  - turbo.json\n  - biome.json\n  - tooling/typescript/base.json\n  - tooling/typescript/react-library.json\n  - tooling/typescript/nextjs.json\n  - tooling/typescript/package.json\n\nNotes\n- routes, Convex functions, and UI components align with the PRD stack (TanStack Start + Convex + UI kit). No stray frameworks detected.\n- Next: run targeted searches to map key implementations for 1.2 (session setup, voice agent hooks, Convex endpoints, content packs).\n</info added on 2025-08-10T19:33:55.945Z>",
            "status": "done",
            "testStrategy": "Verify that all expected files are listed and categorized, cross-checking with manual inspection for completeness."
          },
          {
            "id": 2,
            "title": "Identify Key Implemented Components",
            "description": "Search the codebase for implementations of session setup, voice agent, Convex backend, and content packs using Grep or equivalent tools.",
            "dependencies": [
              "1.1"
            ],
            "details": "Run targeted Grep searches for keywords and module names related to session setup, voice agent, Convex backend, and content packs. Document locations and brief descriptions of each identified component.\n<info added on 2025-08-10T19:35:00.840Z>\nSearch results summary:\n\nVoice agent / ElevenLabs:\n- No in-repo code references found for ElevenLabs/ConvAI SDKs (`@11labs/react`, `useConversation`, `clientTools`, `show_snippet`, `highlight_lines`). Only mentions appear in PRD docs. Conclusion: voice agent integration not yet implemented.\n\nConvex backend API endpoints (per PRD):\n- No direct matches for `createSession|endSession|listSessions|getSessionSummary|saveTranscript|saveEvaluation` in code.\n- Existing Convex modules present: `packages/backend/convex/{auth.ts, auth.config.ts, http.ts, init.ts, schema.ts, subscriptions.ts, users.ts, web.ts, utils/validators.ts}`.\n\nTanStack routes / Router:\n- App routes and router entries confirmed:\n  - `apps/app/src/router.tsx`, `apps/app/src/routes/{__root.tsx,index.tsx,login.tsx,_authed/route.tsx,_authed/dashboard.tsx}` and generated `routeTree.gen.ts`.\n\nContent packs / JD conditioning:\n- No code references for snippet library or scenario seeds; only PRD mentions in `docs/technical-phone-screen-mvp.md`.\n\nImplications:\n- Backend: Convex scaffolding exists, but PRD-specific APIs are not implemented yet.\n- Frontend: TanStack Start routes scaffolded. No voice or content services wired.\n\nNext for 1.2:\n- Drill into Convex files to catalog current queries/mutations (users, auth, subscriptions) for reuse or refactor points.\n- Then proceed to 1.3 (stack confirmation from package.json + entry points) and 1.4 (module relationship mapping).\n</info added on 2025-08-10T19:35:00.840Z>\n<info added on 2025-08-10T19:36:32.318Z>\nConvex catalog (existing)\n- Queries/Mutations/Actions exports:\n  - users.ts (query/mutation signatures present)\n  - web.ts (exports present)\n  - http.ts (httpRouter/addRoute present)\n- Auth usage\n  - No direct ctx.auth or getUserIdentity references detected in grep; auth.ts/auth.config.ts exist and will need auditing (likely Clerk JWT per notes in tasks).\n- Config/schema\n  - schema.ts, convex.config.ts present; subscriptions.ts, utils/validators.ts present; init.ts exists for seeding.\n\nStack confirmation (from package.json files)\n- Monorepo managed by Turbo + Bun. Workspaces: packages/*, apps/*, tooling/*\n- App (@syntaxia/app): TanStack Start/Router v1.128.x, Vite 7, Clerk Start SDK, Tailwind v4, uses @syntaxia/ui.\n- Backend (@syntaxia/backend): convex ^1.25.4; @convex-dev/auth present (migration work planned); Polar SDK present (payments); arktype + env-core present.\n- UI (@syntaxia/ui): Shadcn/Radix-based component lib with exports for sidebar/app-sidebar and globals.css.\n\nConclusion\n- Good scaffold across app/backend/ui. PRD-specific endpoints and voice integration remain to be implemented. Next: proceed to 1.3/1.4 to lock stack and map relationships, then we can pick the first implementation task (most likely Convex schema/APIs per PRD).\n</info added on 2025-08-10T19:36:32.318Z>",
            "status": "done",
            "testStrategy": "Confirm that all relevant implementations are found and mapped to their respective files and modules."
          },
          {
            "id": 3,
            "title": "Analyze Technology Stack and Frameworks",
            "description": "Review package.json, README.md, and main entry points to determine the frameworks, libraries, and runtime environments used in the project.",
            "dependencies": [
              "1.1"
            ],
            "details": "Extract and document dependencies, scripts, and configuration from package.json. Cross-reference with README.md and entry files to confirm usage of TanStack Start, Convex, Node/TypeScript, and other major technologies.\n<info added on 2025-08-10T19:38:37.448Z>\nStack confirmation:\n\n- Monorepo: Turbo + Bun workspaces (packages/*, apps/*, tooling/*)\n- Frontend: TanStack Start/Router (^1.128), Vite 7, Clerk Start SDK, Tailwind v4, uses @syntaxia/ui\n- Backend: Convex ^1.25.4, @convex-dev/auth present, Polar SDK present, arktype, env-core; Convex modules in packages/backend/convex/*\n- UI: Shadcn/Radix components in @syntaxia/ui with many exports including sidebar/app-sidebar and globals.css\n- Tooling: Biome, TS 5.9 catalog, turbo scripts\n\nKey files:\n- apps/app/src/router.tsx, apps/app/src/routes/**, apps/app/src/routeTree.gen.ts (generated)\n- packages/backend/convex/{schema.ts, users.ts, web.ts, http.ts, auth.ts, auth.config.ts, init.ts}\n- packages/ui/src/components/*, packages/ui/src/utils/*, globals via exports\n\nVerdict:\n- Stack matches PRD: TanStack Start + Convex + Voice agent TBD + content packs TBD.\n- Ready to proceed to schema/APIs per PRD and voice integration tasks.\n</info added on 2025-08-10T19:38:37.448Z>",
            "status": "done",
            "testStrategy": "Validate findings against actual code imports and usage patterns in main entry points."
          },
          {
            "id": 4,
            "title": "Map Architectural Patterns and Module Relationships",
            "description": "Analyze the organization of code and inter-module dependencies to identify architectural patterns and system structure.",
            "dependencies": [
              "1.1",
              "1.2",
              "1.3"
            ],
            "details": "Use static analysis tools and manual inspection to map out module dependencies, control flow, and architectural conventions (e.g., layering, service boundaries). Document findings with diagrams or structured notes.\n<info added on 2025-08-10T19:39:04.892Z>\nModule relationship map (1.4) — high level\n\n- Frontend (apps/app)\n  - `src/router.tsx` configures TanStack Router; routes under `src/routes/**` provide layout (`__root.tsx`) and pages (`index.tsx`, `login.tsx`, `_authed/*`).\n  - UI dependencies imported from `@syntaxia/ui/*` (design system). No direct backend calls found here yet.\n\n- Backend (packages/backend/convex)\n  - `schema.ts` defines data model; `_generated/*` provides typed clients.\n  - HTTP: `http.ts` exposes routes via Convex `httpRouter` (no auth routes wired yet per grep).\n  - App logic files present: `users.ts`, `web.ts`, `subscriptions.ts` (likely Convex query/mutation/action containers).\n  - Auth: `auth.ts` and `auth.config.ts` exist; migration to Clerk tokens is planned in tasks.\n\n- UI Library (packages/ui)\n  - Components consumed by app; no cross-backend coupling.\n\n- Cross-boundaries\n  - No voice agent module present (TBD).\n  - No explicit clientTools or agent→UI bridge in app yet (TBD).\n  - Payments libs present in backend but no exposed checkout/webhook handlers yet.\n\nNext\n- This map is sufficient to proceed with Task 3: design Convex schema and APIs (sessions, transcripts, evaluations, question_sets) and implement endpoints (`createSession`, `endSession`, `saveTranscript`, `saveEvaluation`, `listSessions`, `getSessionSummary`).\n</info added on 2025-08-10T19:39:04.892Z>",
            "status": "done",
            "testStrategy": "Ensure that the documented architecture accurately reflects the codebase, validated by peer review or automated dependency graphs."
          },
          {
            "id": 5,
            "title": "Document Findings for Reference",
            "description": "Compile all analysis results into a structured document for use in subsequent tasks and onboarding.",
            "dependencies": [
              "1.1",
              "1.2",
              "1.3",
              "1.4"
            ],
            "details": "Create a comprehensive report summarizing file inventory, implemented components, technology stack, and architectural patterns. Include references to source files and diagrams where applicable.\n<info added on 2025-08-10T19:40:06.742Z>\nWhere to find all findings (Task 1 consolidated)\n\n- 1.1 Inventory: See subtask 1.1 details in `.taskmaster/tasks/tasks.json` (grouped file list by workspace)\n- 1.2 Components: See subtask 1.2 details (search results: routes present; no ElevenLabs integration; PRD Convex APIs not yet implemented; Convex scaffold exists)\n- 1.3 Stack: See subtask 1.3 details (frameworks, key versions, key files)\n- 1.4 Map: See subtask 1.4 details (module relationships and next implications)\n\nQuick links\n- App router and routes: `apps/app/src/router.tsx`, `apps/app/src/routes/**`\n- Convex core: `packages/backend/convex/{schema.ts, users.ts, web.ts, http.ts, auth.ts, auth.config.ts, init.ts}`\n- UI kit: `packages/ui/src/components/*`, `packages/ui/src/utils/*`, exports in `packages/ui/package.json`\n- Workspace manifests: root `package.json`, `apps/app/package.json`, `packages/backend/package.json`, `packages/ui/package.json`\n\nConclusion\n- All findings are embedded in Task 1’s subtasks (1.1–1.4). Use `task-master show 1.1,1.2,1.3,1.4` to view them together, or open `.taskmaster/tasks/tasks.json` and search for those IDs.\n- Ready to proceed to Task 3 (Convex schema/APIs per PRD).\n</info added on 2025-08-10T19:40:06.742Z>",
            "status": "done",
            "testStrategy": "Review documentation for completeness, clarity, and accuracy; ensure it supports downstream implementation and planning."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement JD-Conditioned Session Setup",
        "description": "Enable users to input a job description (JD) and generate a session plan conditioned on senior full-stack engineering competencies.",
        "details": "Create a UI flow for JD input and senior-level session preview using TanStack Start. Implement backend logic in Convex to parse JD, extract competencies, and generate session sections (A–D) with senior-calibrated prompts/snippets. Use TypeScript for type safety and ensure streaming SSR for responsiveness.",
        "testStrategy": "Test with various JDs to confirm correct competency extraction, session plan generation, and UI updates. Validate backend parsing and session creation logic.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement JD Input and Session Preview UI Flow",
            "description": "Create a user interface using TanStack Start that allows users to input a job description (JD) and preview the generated senior-level session plan.",
            "dependencies": [],
            "details": "Utilize TanStack Start's routing and component system to build a form for JD input and session preview. Integrate real-time validation and preview capabilities for session plans.",
            "status": "done",
            "testStrategy": "Test UI flow with various JDs to confirm correct data capture, navigation, and preview rendering."
          },
          {
            "id": 2,
            "title": "Implement Backend JD Parsing and Competency Extraction in Convex",
            "description": "Develop Convex backend logic to parse the submitted JD and extract relevant senior full-stack engineering competencies required for session plan generation.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create Convex server functions to receive JD input, apply parsing algorithms or models, and output a structured list of competencies. Ensure robust error handling and logging for edge cases.",
            "status": "pending",
            "testStrategy": "Validate competency extraction accuracy using a diverse set of JDs, including edge cases and ambiguous descriptions."
          },
          {
            "id": 3,
            "title": "Generate Session Plan Sections (A–D) with Calibrated Prompts and Snippets",
            "description": "Based on extracted competencies, generate session plan sections (A–D) with tailored prompts and code snippets, ensuring alignment with senior full-stack engineering expectations.",
            "dependencies": [
              "2.2"
            ],
            "details": "Implement logic to map competencies to session sections, calibrate prompts/snippets for each section, and ensure content is dynamically generated per user input.",
            "status": "pending",
            "testStrategy": "Test session plan generation for completeness, relevance, and calibration across multiple JD combinations."
          },
          {
            "id": 4,
            "title": "Ensure Type Safety and Streaming SSR for Responsiveness",
            "description": "Integrate TypeScript throughout the stack for type safety and implement streaming server-side rendering (SSR) in TanStack Start to optimize responsiveness during session plan generation.",
            "dependencies": [
              "2.3"
            ],
            "details": "Define and enforce TypeScript types for all data structures and API contracts. Configure TanStack Start to use streaming SSR for session plan previews and updates.",
            "status": "pending",
            "testStrategy": "Run type checks and SSR performance tests. Confirm that session previews update responsively and type errors are caught during development."
          },
          {
            "id": 5,
            "title": "Integrate and Validate End-to-End Session Setup Flow",
            "description": "Combine UI, backend, and SSR components into a seamless end-to-end flow, ensuring users can input a JD and receive a generated senior-level session plan preview.",
            "dependencies": [
              "2.4"
            ],
            "details": "Wire up all components, handle state management, and ensure error handling and user feedback are robust. Prepare for integration with downstream tasks such as content packs and analytics.",
            "status": "pending",
            "testStrategy": "Perform end-to-end tests with real and synthetic JDs, verifying correct flow, data integrity, and user experience from input to session preview."
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop Voice Interview Flow (A–D Sections)",
        "description": "Build the core voice interview experience with agent-driven turn-taking, barge-in support, and section transitions (Background, Code, Scenario, Wrap-up) using the ElevenLabs React SDK.",
        "details": "Integrate ElevenLabs TTS and ASR via the official React SDK (@elevenlabs/react) using the useConversation() hook. Leverage native ElevenLabs capabilities for turn-taking and barge-in detection. Design a state machine to orchestrate interview flow (A–D), handling agent prompts, candidate responses, and UI sync. Ensure seamless client tools integration with React SDK state management.",
        "testStrategy": "Simulate full interview sessions, testing voice input/output, section transitions, barge-in, and agent-driven UI events. Validate native ASR/TTS accuracy and latency.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate ElevenLabs TTS and ASR Streaming",
            "description": "Implement real-time text-to-speech (TTS) and automatic speech recognition (ASR) using ElevenLabs via the official React SDK, ensuring accurate, low-latency transcription and seamless integration.",
            "dependencies": [],
            "details": "Use the useConversation() hook for bidirectional audio streaming, leveraging built-in handlers for status, isSpeaking, and onMessage. Optimize for minimal latency and high transcription accuracy.",
            "status": "pending",
            "testStrategy": "Simulate voice input/output in various network conditions. Measure TTS/ASR latency and transcription accuracy across all interview sections."
          },
          {
            "id": 2,
            "title": "Design and Implement Interview State Machine",
            "description": "Develop a robust state machine to orchestrate the interview flow across the Background, Code, Scenario, and Wrap-up sections, managing agent prompts, candidate responses, and transitions.",
            "dependencies": [
              "3.1"
            ],
            "details": "Define clear states and transitions for each interview section. Ensure the state machine supports agent-driven turn-taking, barge-in handling, and error recovery.",
            "status": "pending",
            "testStrategy": "Run simulated interviews to verify correct state transitions, section sequencing, and recovery from unexpected user input."
          },
          {
            "id": 3,
            "title": "Implement Agent-Driven Turn-Taking and Barge-In Support",
            "description": "Enable the agent to manage conversational turns, detect and handle user barge-ins (interruptions), and resume or adapt the flow accordingly.",
            "dependencies": [
              "3.2"
            ],
            "details": "Utilize ElevenLabs' native turn-taking and barge-in detection capabilities. Allow the agent to pause, resume, or adjust its responses based on barge-in events.",
            "status": "pending",
            "testStrategy": "Test with users interrupting agent prompts at various points. Validate that the system gracefully handles interruptions and maintains conversational coherence."
          },
          {
            "id": 4,
            "title": "Synchronize UI with Agent Actions via clientTools",
            "description": "Ensure the agent can trigger UI updates (e.g., show_snippet, highlight_lines) in real time using clientTools, keeping the visual interface in sync with the voice interaction.",
            "dependencies": [
              "3.2"
            ],
            "details": "Implement clientTools hooks in the frontend and connect them to agent actions in the state machine. Support dynamic UI updates based on agent instructions.",
            "status": "pending",
            "testStrategy": "Simulate agent-triggered UI events during interviews. Confirm that UI updates occur promptly and accurately in response to agent commands."
          },
          {
            "id": 5,
            "title": "Validate End-to-End Interview Flow and Section Transitions",
            "description": "Conduct comprehensive testing of the full voice interview experience, including section transitions, agent-candidate interactions, barge-in handling, and UI synchronization.",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "Simulate realistic interview sessions covering all A–D sections. Monitor for smooth transitions, accurate voice input/output, and correct UI behavior throughout.",
            "status": "pending",
            "testStrategy": "Run end-to-end interview scenarios with multiple users. Collect feedback on flow, latency, and usability. Address any breakdowns in state, voice, or UI synchronization."
          }
        ]
      },
      {
        "id": 4,
        "title": "On-Screen Content Rendering and Voice-Only Fallback",
        "description": "Render curated full-stack code snippets, diffs, and logs in the UI during the interview, with voice-only fallback for semantic summaries and on-demand readouts.",
        "details": "Implement UI components for displaying code/logs/diffs using TanStack Start. Enable agent to reference line ranges/blocks and trigger highlights/zoom via clientTools. For voice-only mode, provide structured summaries and readouts of ≤25-line blocks. Ensure accessibility and responsive design.",
        "testStrategy": "Test rendering of various content types during sessions. Validate agent-triggered UI updates and fallback summaries/readouts in voice-only mode.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement UI Components for Code, Diff, and Log Rendering",
            "description": "Develop reusable UI components using TanStack Start to render code snippets, diffs, and logs with support for syntax highlighting, line numbers, and responsive layouts.",
            "dependencies": [],
            "details": "Ensure components handle various content types and integrate with TanStack Start's SSR and routing features for optimal performance and maintainability.",
            "status": "pending",
            "testStrategy": "Test rendering of diverse code, diff, and log samples across devices and screen sizes. Validate SSR behavior and client-side navigation."
          },
          {
            "id": 2,
            "title": "Integrate Agent-Driven Line Range Referencing and Highlight/Zoom Controls",
            "description": "Enable the agent to reference specific line ranges or blocks within rendered content and trigger UI highlights or zoom actions via clientTools.",
            "dependencies": [
              "4.1"
            ],
            "details": "Implement mechanisms for the agent to specify line/block references and for the UI to respond with visual highlights or focused views. Ensure seamless interaction between agent commands and UI updates.",
            "status": "pending",
            "testStrategy": "Simulate agent commands to reference and highlight/zoom lines or blocks. Verify correct UI response and user feedback."
          },
          {
            "id": 3,
            "title": "Develop Voice-Only Fallback Mode with Structured Summaries and Readouts",
            "description": "Implement a voice-only mode that provides semantic summaries and on-demand readouts of ≤25-line content blocks, ensuring clarity and structure.",
            "dependencies": [
              "4.1"
            ],
            "details": "Design logic to segment content into ≤25-line blocks, generate structured summaries, and support on-demand readouts triggered by agent or user requests.",
            "status": "pending",
            "testStrategy": "Test fallback behavior by disabling visual UI and verifying summary/readout accuracy, structure, and responsiveness to triggers."
          },
          {
            "id": 4,
            "title": "Ensure Accessibility and Responsive Design for All Content Modes",
            "description": "Apply accessibility best practices and responsive design principles to all UI components and voice-only interactions, supporting diverse user needs and devices.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Implement ARIA roles, keyboard navigation, screen reader support, and responsive layouts. Validate that both visual and voice-only modes are fully accessible.",
            "status": "pending",
            "testStrategy": "Conduct accessibility audits using automated tools and manual testing. Validate responsive behavior on multiple devices and screen sizes."
          },
          {
            "id": 5,
            "title": "Validate Agent-Triggered UI Updates and Fallbacks During Live Sessions",
            "description": "Test the end-to-end flow of agent-triggered content rendering, highlights, and voice-only fallbacks during simulated interview sessions.",
            "dependencies": [
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Simulate live sessions with agent-driven events, verifying that UI updates, highlights, zooms, and voice-only summaries/readouts function as intended in real time.",
            "status": "pending",
            "testStrategy": "Run comprehensive session simulations covering all content types, agent actions, and fallback scenarios. Log and resolve any discrepancies or failures."
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Rubric-Based Scoring and Feedback Engine",
        "description": "Create a scoring system based on rubric dimensions (Communication, Debugging, Breadth, Operationalization, Product sense) with anchored examples and comments.",
        "details": "Implement backend logic in Convex for scoring responses per section. Use deterministic LLM prompts for minimal variance. Store scores and comments in Convex tables. Expose scoring API for frontend consumption. Ensure scores are anchored to explicit examples (1–4 scale).",
        "testStrategy": "Validate scoring accuracy and consistency across sessions. Test with sample responses to ensure rubric anchors and comments are correctly applied.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Rubric Schema and Anchored Examples",
            "description": "Design the data schema for rubric dimensions (Communication, Debugging, Breadth, Operationalization, Product sense), including explicit 1–4 scale anchors and example responses for each score.",
            "dependencies": [],
            "details": "Specify Convex table structures to store rubric definitions, scale anchors, and example comments. Ensure extensibility for future rubric updates.",
            "status": "pending",
            "testStrategy": "Verify schema correctness by creating and retrieving rubric definitions and anchors via Convex queries."
          },
          {
            "id": 2,
            "title": "Implement Deterministic LLM Scoring Logic",
            "description": "Develop backend logic in Convex to score user responses per rubric section using deterministic LLM prompts, minimizing variance and ensuring reproducibility.",
            "dependencies": [
              "5.1"
            ],
            "details": "Integrate LLM scoring with prompt templates anchored to rubric examples. Ensure each response is scored on the 1–4 scale with rationale comments.",
            "status": "pending",
            "testStrategy": "Test with sample responses to confirm deterministic outputs and correct application of rubric anchors."
          },
          {
            "id": 3,
            "title": "Store Scores and Feedback in Convex Tables",
            "description": "Create Convex tables and mutations to persist scores, rationale comments, and section-level feedback for each user response.",
            "dependencies": [
              "5.2"
            ],
            "details": "Design efficient data models for storing per-section scores and comments, linked to session and user identifiers.",
            "status": "pending",
            "testStrategy": "Validate that scores and comments are correctly stored and retrievable for multiple sessions and users."
          },
          {
            "id": 4,
            "title": "Expose Scoring and Feedback API",
            "description": "Develop a Convex API endpoint to allow frontend clients to submit responses and retrieve rubric-based scores and feedback.",
            "dependencies": [
              "5.3"
            ],
            "details": "Implement API functions for scoring requests, feedback retrieval, and error handling. Ensure secure and performant access patterns.",
            "status": "pending",
            "testStrategy": "Test API endpoints with simulated frontend requests, verifying correct scoring, feedback delivery, and error responses."
          },
          {
            "id": 5,
            "title": "Validate Scoring Consistency and Anchor Alignment",
            "description": "Systematically test the scoring engine for accuracy, consistency across sessions, and correct alignment with rubric anchors and example comments.",
            "dependencies": [
              "5.4"
            ],
            "details": "Use a suite of sample responses to evaluate scoring variance, anchor application, and feedback quality. Document findings and iterate on prompt or schema as needed.",
            "status": "pending",
            "testStrategy": "Run repeated scoring tests with identical and varied responses, confirming minimal variance and correct anchor usage in feedback."
          }
        ]
      },
      {
        "id": 6,
        "title": "Generate Transcript and Session Report",
        "description": "Produce a full transcript with highlighted moments, rubric scores, prioritized action plan, and tailored follow-up prompts.",
        "details": "Capture transcript segments during sessions, annotate highlights and timestamps. Implement report generator to compile transcript, scores, action plan, and practice prompts. Support export to Markdown, PDF, and JSON formats. Store reports in Convex for retrieval.",
        "testStrategy": "Run end-to-end session and verify transcript accuracy, highlight detection, scoring integration, and export functionality.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Capture and Segment Session Transcript",
            "description": "Implement real-time or post-session transcription to capture all spoken content during the session, segmenting the transcript by speaker and timestamp.",
            "dependencies": [],
            "details": "Utilize AI-powered transcription tools to record and segment session audio, ensuring accurate speaker labeling and timestamping for each segment.",
            "status": "pending",
            "testStrategy": "Run simulated sessions and verify that the transcript accurately reflects all spoken content, with correct segmentation and timestamps."
          },
          {
            "id": 2,
            "title": "Annotate Highlights and Key Moments",
            "description": "Develop functionality to annotate transcript segments with highlights, comments, and tags for significant moments during the session.",
            "dependencies": [
              "6.1"
            ],
            "details": "Enable manual or automated annotation of transcript segments to mark important exchanges, decisions, or noteworthy responses, storing highlight metadata alongside transcript data.",
            "status": "pending",
            "testStrategy": "Review annotated transcripts to confirm that highlights and comments are correctly linked to relevant segments and timestamps."
          },
          {
            "id": 3,
            "title": "Integrate Rubric Scoring and Feedback",
            "description": "Incorporate rubric-based scoring for each relevant transcript segment, attaching scores and feedback comments to the transcript.",
            "dependencies": [
              "6.2"
            ],
            "details": "Fetch or calculate rubric scores (e.g., Communication, Debugging) for each session section, and append structured feedback to the corresponding transcript segments.",
            "status": "pending",
            "testStrategy": "Validate that rubric scores and feedback are present, accurate, and correctly associated with transcript sections."
          },
          {
            "id": 4,
            "title": "Generate Action Plan and Follow-up Prompts",
            "description": "Synthesize a prioritized action plan and tailored follow-up prompts based on transcript highlights and rubric feedback.",
            "dependencies": [
              "6.3"
            ],
            "details": "Analyze annotated highlights and rubric feedback to automatically generate actionable next steps and personalized practice prompts for the participant.",
            "status": "pending",
            "testStrategy": "Check that the action plan and prompts are relevant, actionable, and tailored to the session content and participant performance."
          },
          {
            "id": 5,
            "title": "Compile and Export Session Report",
            "description": "Implement a report generator that compiles the full transcript, highlights, rubric scores, action plan, and prompts, supporting export to Markdown, PDF, and JSON formats, and storing reports in Convex.",
            "dependencies": [
              "6.4"
            ],
            "details": "Design and build a report compilation and export module, ensuring all required elements are included and formatted for multiple export types. Integrate with Convex for persistent storage and retrieval.",
            "status": "pending",
            "testStrategy": "Export reports in all supported formats and verify completeness, formatting, and successful storage and retrieval from Convex."
          }
        ]
      },
      {
        "id": 7,
        "title": "Integrate Content Packs and Scenario Seeds",
        "description": "Provide a library of curated full-stack code snippets and scenario seeds with metadata for senior-level practice and JD conditioning.",
        "details": "Implement content service to manage snippet library (8–12 curated full-stack snippets, 15–20 scenario seeds) with metadata (risks, testability hooks). Enable retrieval based on JD input. Ensure extensibility for future specialized packs.",
        "testStrategy": "Test snippet/scenario retrieval for various JDs. Validate metadata integrity and correct matching to session requirements.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Metadata Schema for Snippets and Scenario Seeds",
            "description": "Define a comprehensive metadata schema for code snippets and scenario seeds, including fields for risks, testability hooks, and extensibility for future specialized packs.",
            "dependencies": [],
            "details": "Specify required and optional metadata attributes, ensuring compatibility with retrieval and filtering mechanisms. Document schema for developer reference.",
            "status": "pending",
            "testStrategy": "Validate schema by creating sample metadata entries and ensuring all required fields are present and correctly typed."
          },
          {
            "id": 2,
            "title": "Implement Content Service for Library Management",
            "description": "Develop a backend service to manage the library of code snippets (8–12 curated full-stack) and scenario seeds (15–20), supporting CRUD operations and metadata association.",
            "dependencies": [
              "7.1"
            ],
            "details": "Use a scalable data store and API endpoints to add, update, delete, and retrieve content items with metadata. Ensure extensibility for future packs.",
            "status": "pending",
            "testStrategy": "Test CRUD operations for snippets and seeds, verifying metadata integrity and service responsiveness."
          },
          {
            "id": 3,
            "title": "Enable JD-Based Retrieval and Matching",
            "description": "Implement logic to retrieve relevant snippets and scenario seeds based on job description (JD) input, leveraging metadata for accurate matching.",
            "dependencies": [
              "7.2"
            ],
            "details": "Develop filtering and ranking algorithms to select content items that best fit session requirements. Integrate with session setup flow.",
            "status": "pending",
            "testStrategy": "Simulate retrieval for various JDs, confirming correct matching and relevance of returned items."
          },
          {
            "id": 4,
            "title": "Integrate Extensibility for Specialized Content Packs",
            "description": "Design and implement mechanisms to support future addition of specialized content packs without disrupting existing functionality.",
            "dependencies": [
              "7.2"
            ],
            "details": "Define interfaces and extension points for new packs, ensuring backward compatibility and ease of integration.",
            "status": "pending",
            "testStrategy": "Add a mock specialized pack and verify seamless integration, retrieval, and metadata handling."
          },
          {
            "id": 5,
            "title": "Validate and Test Content Pack and Scenario Seed Library",
            "description": "Conduct comprehensive testing of the content library, including retrieval accuracy, metadata integrity, and extensibility features.",
            "dependencies": [
              "7.3",
              "7.4"
            ],
            "details": "Develop test cases covering various JDs and pack extensions. Ensure all functionalities meet requirements and edge cases are handled.",
            "status": "pending",
            "testStrategy": "Run automated and manual tests for retrieval, metadata validation, and extensibility. Review results and address any issues found."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Secure Persistence and Data Models in Convex",
        "description": "Define and implement Convex tables for sessions, transcripts, scores, JD profiles, and snippet metadata, ensuring secure and efficient storage.",
        "details": "Design Convex schema per PRD data models. Implement server functions for CRUD operations and secure access. Store secrets in server environment and ensure PII-light transcripts by default.",
        "testStrategy": "Test data creation, retrieval, update, and deletion for all models. Validate security and privacy requirements.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Convex Schema for Required Data Models",
            "description": "Define Convex tables for sessions, transcripts, scores, JD profiles, and snippet metadata, ensuring alignment with PRD data models and privacy requirements.",
            "dependencies": [],
            "details": "Draft the schema in convex/schema.ts using defineSchema and defineTable, specifying fields, types, and indexes as needed for efficient querying and minimal PII exposure.",
            "status": "pending",
            "testStrategy": "Review schema definitions for completeness and correctness; validate type safety and field constraints using TypeScript."
          },
          {
            "id": 2,
            "title": "Implement Secure CRUD Server Functions",
            "description": "Develop server-side functions for create, read, update, and delete operations on all defined tables, enforcing access control and argument validation.",
            "dependencies": [
              "8.1"
            ],
            "details": "Use Convex query and mutation wrappers with argument validators for all public functions. Ensure only authorized users can access or modify data, and restrict updates to allowed fields.",
            "status": "pending",
            "testStrategy": "Test all CRUD endpoints for correct behavior, access control enforcement, and input validation using automated and manual tests."
          },
          {
            "id": 3,
            "title": "Integrate Secure Secret and Environment Variable Storage",
            "description": "Configure Convex to store sensitive secrets (e.g., API keys) in the server environment, ensuring they are never exposed to clients or persisted in user-accessible tables.",
            "dependencies": [
              "8.1"
            ],
            "details": "Leverage Convex environment variable support and server-only code to access secrets. Document usage patterns and audit code for accidental exposure.",
            "status": "pending",
            "testStrategy": "Verify secrets are accessible only in server context and not leaked to clients or logs; attempt unauthorized access to confirm isolation."
          },
          {
            "id": 4,
            "title": "Enforce PII-Light Transcript Storage by Default",
            "description": "Implement logic to sanitize and minimize personally identifiable information (PII) in transcript storage, applying redaction or exclusion rules as required.",
            "dependencies": [
              "8.2"
            ],
            "details": "Develop helper functions to process transcripts before storage, removing or masking PII fields. Document sanitization rules and ensure compliance with privacy standards.",
            "status": "pending",
            "testStrategy": "Create test transcripts with PII, store them, and verify that stored data is PII-light according to defined rules."
          },
          {
            "id": 5,
            "title": "Validate Data Security, Privacy, and Performance",
            "description": "Conduct comprehensive testing of data creation, retrieval, update, and deletion for all models, with a focus on security, privacy, and storage efficiency.",
            "dependencies": [
              "8.2",
              "8.3",
              "8.4"
            ],
            "details": "Perform end-to-end tests simulating real usage, including edge cases for access control, data leakage, and schema evolution. Monitor performance and storage metrics.",
            "status": "pending",
            "testStrategy": "Run automated and manual tests covering all CRUD operations, security boundaries, and privacy requirements; review logs and metrics for anomalies."
          }
        ]
      },
      {
        "id": 9,
        "title": "Enable Agent-Driven UI Control via Tools API",
        "description": "Allow the voice agent to trigger UI updates (e.g., show_snippet, highlight_lines) using clientTools and ConvAI Tools API.",
        "details": "Implement clientTools interface in frontend and backend endpoints in Convex for agent-driven UI events. Ensure idempotency and reliable event handling. Integrate with voice agent state machine.",
        "testStrategy": "Simulate agent-triggered UI events during sessions. Validate correct UI updates and backend event processing.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design ClientTools Interface for UI Event Triggers",
            "description": "Specify and document the clientTools interface to support agent-driven UI events such as show_snippet and highlight_lines, ensuring clear event payload structure and extensibility.",
            "dependencies": [],
            "details": "Define the event types, payload schemas, and invocation patterns for clientTools. Ensure compatibility with frontend frameworks and future UI actions.",
            "status": "pending",
            "testStrategy": "Review interface documentation and simulate event payloads to verify schema correctness and extensibility."
          },
          {
            "id": 2,
            "title": "Implement Frontend Event Handling via ClientTools",
            "description": "Integrate the clientTools interface into the frontend, enabling the voice agent to trigger UI updates and ensuring correct rendering of events like show_snippet and highlight_lines.",
            "dependencies": [
              "9.1"
            ],
            "details": "Connect clientTools to UI components, handle incoming event payloads, and update the UI reactively. Ensure event deduplication and idempotency in the UI layer.",
            "status": "pending",
            "testStrategy": "Simulate agent-triggered events and validate UI updates, checking for correct rendering and prevention of duplicate actions."
          },
          {
            "id": 3,
            "title": "Develop Convex Backend Endpoints for UI Event Processing",
            "description": "Create Convex backend endpoints to receive, process, and persist agent-driven UI events, ensuring reliable event delivery and state synchronization.",
            "dependencies": [
              "9.1"
            ],
            "details": "Implement endpoints to accept UI event requests, validate payloads, and update session state. Ensure backend logic supports idempotency and event ordering.",
            "status": "pending",
            "testStrategy": "Send test events to endpoints, verify correct state updates, and confirm idempotent processing under repeated requests."
          },
          {
            "id": 4,
            "title": "Integrate Agent State Machine with Tools API",
            "description": "Connect the voice agent's state machine to the Tools API, enabling it to trigger UI events at appropriate dialogue states and transitions.",
            "dependencies": [
              "9.2",
              "9.3"
            ],
            "details": "Modify the agent state machine to invoke clientTools and backend endpoints during relevant states (e.g., after agent prompts or candidate responses). Ensure event triggers are contextually accurate.",
            "status": "pending",
            "testStrategy": "Run simulated interview flows, verifying that agent actions result in correct UI events and backend updates at each state transition."
          },
          {
            "id": 5,
            "title": "Validate End-to-End Idempotency and Reliability of Agent-Driven UI Events",
            "description": "Test the complete flow from agent event trigger to UI update and backend processing, ensuring idempotency, reliability, and correct event handling under various scenarios.",
            "dependencies": [
              "9.2",
              "9.3",
              "9.4"
            ],
            "details": "Design test cases for duplicate event triggers, network failures, and concurrent sessions. Monitor event propagation and verify that UI and backend states remain consistent and correct.",
            "status": "pending",
            "testStrategy": "Simulate edge cases and failure scenarios, confirming that repeated or failed events do not cause inconsistent UI or backend states."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Session Analytics and Feature Flagging (Optional MVP Scope)",
        "description": "Add basic product analytics and feature flagging to monitor usage and enable/disable features for experimentation.",
        "details": "Integrate analytics service (e.g., PostHog, Segment) for session tracking and event logging. Implement feature flagging system to control access to experimental features. Ensure privacy compliance and minimal performance impact.",
        "testStrategy": "Verify analytics event capture and feature flag toggling. Test reporting and privacy controls.",
        "priority": "low",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Analytics Objectives and Key Metrics",
            "description": "Establish clear objectives for product analytics and identify the key metrics and events to track, ensuring alignment with business goals and MVP requirements.",
            "dependencies": [],
            "details": "Collaborate with stakeholders to determine what user behaviors, feature usage, and session data are most critical to monitor. Document the specific events and KPIs (e.g., session start, feature engagement, retention) that will guide analytics implementation.",
            "status": "pending",
            "testStrategy": "Review documented objectives and metrics with stakeholders to confirm completeness and alignment with business priorities."
          },
          {
            "id": 2,
            "title": "Integrate Analytics Service for Session Tracking",
            "description": "Select and integrate a suitable analytics service (e.g., PostHog, Segment) to capture session data and log defined events within the product.",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement SDKs or APIs for the chosen analytics platform in the codebase. Configure event tracking for all identified metrics, ensuring data is sent accurately and efficiently.",
            "status": "pending",
            "testStrategy": "Trigger tracked events in a test environment and verify their appearance in the analytics dashboard. Confirm that all required events are logged with correct metadata."
          },
          {
            "id": 3,
            "title": "Implement Feature Flagging System",
            "description": "Develop or integrate a feature flagging solution to enable or disable experimental features dynamically for targeted user segments.",
            "dependencies": [
              "10.1"
            ],
            "details": "Choose a feature flagging tool or build a lightweight system. Integrate it with the product to control feature access based on flags, supporting experimentation and gradual rollouts.",
            "status": "pending",
            "testStrategy": "Toggle feature flags in staging and verify that features are enabled/disabled as expected for different user groups."
          },
          {
            "id": 4,
            "title": "Ensure Privacy Compliance and Performance Optimization",
            "description": "Review analytics and feature flagging implementations to ensure compliance with privacy regulations (e.g., GDPR) and minimize performance impact.",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "Audit data collection for PII, implement user consent mechanisms if required, and optimize event logging to avoid latency or resource overhead.",
            "status": "pending",
            "testStrategy": "Conduct privacy compliance checks and performance profiling. Validate that no unauthorized PII is collected and that analytics do not degrade user experience."
          },
          {
            "id": 5,
            "title": "Validate Analytics Reporting and Feature Flag Controls",
            "description": "Test and verify that analytics dashboards accurately reflect user sessions and events, and that feature flag toggling works as intended for experimentation.",
            "dependencies": [
              "10.4"
            ],
            "details": "Generate sample reports and review dashboards for data accuracy. Simulate feature flag changes and confirm correct feature exposure in the product.",
            "status": "pending",
            "testStrategy": "Cross-check analytics reports with manual event logs. Test feature flag scenarios and document results for QA sign-off."
          }
        ]
      },
      {
        "id": 11,
        "title": "Integrate Clerk Authentication with Convex",
        "description": "Integrate Clerk authentication with Convex to authenticate queries and mutations using Clerk JWTs.",
        "details": "To integrate Clerk authentication with Convex, follow these steps:\n\n1. **Backend Configuration**: Update the `auth.config.ts` file in the Convex backend to validate Clerk JWTs. Configure the issuer domain and application ID as 'convex'. Ensure that the configuration supports both development and production environments.\n\n2. **Frontend Integration**: Utilize `ConvexProviderWithClerk` and `ClerkProvider` in the frontend. Implement authentication gating using `Authenticated`, `Unauthenticated`, and `useConvexAuth` components to manage access to Convex queries and mutations.\n\n3. **Function Updates**: Replace any legacy Convex authentication methods with `ctx.auth.getUserIdentity()` checks in all queries, mutations, and actions within the Convex functions.\n\n4. **Environment Variables**: Ensure that `VITE_CLERK_PUBLISHABLE_KEY` is set in the frontend environment and `CLERK_JWT_ISSUER_DOMAIN` is configured in the Convex backend environment.\n\n5. **Cleanup**: Remove any existing Convex Auth HTTP routes or providers that are no longer needed, aligning the system with the new authentication flow.\n\nRefer to the official Convex and Clerk documentation for detailed guidance and best practices.",
        "testStrategy": "1. **Backend Testing**: Deploy the updated Convex backend and verify that JWT validation works correctly by testing with valid and invalid tokens.\n\n2. **Frontend Testing**: Ensure that the frontend correctly uses `ConvexProviderWithClerk` and `ClerkProvider` by logging in and accessing Convex queries and mutations. Test both authenticated and unauthenticated states.\n\n3. **Function Testing**: Review all Convex functions to ensure they use `ctx.auth.getUserIdentity()` and test their behavior with authenticated and unauthenticated requests.\n\n4. **Environment Testing**: Verify that the environment variables `VITE_CLERK_PUBLISHABLE_KEY` and `CLERK_JWT_ISSUER_DOMAIN` are correctly set and accessible in their respective environments.\n\n5. **Cleanup Verification**: Confirm that all legacy Convex Auth routes and providers have been removed and that the new authentication flow is fully operational.",
        "status": "done",
        "dependencies": [
          1,
          8
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Convex Backend for Clerk JWT Validation",
            "description": "Update the Convex backend authentication configuration to validate Clerk JWTs, setting the issuer domain and application ID as 'convex'. Ensure the configuration supports both development and production environments.",
            "dependencies": [],
            "details": "Edit or create the `auth.config.ts` file in the Convex backend, referencing the Clerk issuer domain via environment variables (e.g., `CLERK_JWT_ISSUER_DOMAIN`) and set the application ID to 'convex'. Follow Convex and Clerk documentation for correct configuration.\n<info added on 2025-08-10T19:47:13.864Z>\nBackend edits completed:\n- Updated `convex/auth.config.ts` to use `process.env.CLERK_JWT_ISSUER_DOMAIN` with `applicationID: \"convex\"` per Convex & Clerk docs.\n- Removed Convex Auth HTTP routes from `convex/http.ts` (commented import and addHttpRoutes line).\n- Refactored `convex/users.ts` to Clerk via `ctx.auth.getUserIdentity()`; replaced `@convex-dev/auth` usages. Strongly typed identity.subject as `Id<\"users\">`.\n\nNext:\n- Ensure `CLERK_JWT_ISSUER_DOMAIN` is set in Convex dashboard (dev/prod) and `VITE_CLERK_PUBLISHABLE_KEY` in the app env. Then run `npx convex dev` to sync config.\n\nReference: [Convex & Clerk](https://docs.convex.dev/auth/clerk)\n</info added on 2025-08-10T19:47:13.864Z>",
            "status": "done",
            "testStrategy": "Deploy the backend and verify that valid Clerk JWTs are accepted and invalid tokens are rejected in both development and production environments."
          },
          {
            "id": 2,
            "title": "Set Required Environment Variables",
            "description": "Ensure all necessary environment variables for Clerk and Convex integration are set in both frontend and backend environments.",
            "dependencies": [
              "11.1"
            ],
            "details": "Set `VITE_CLERK_PUBLISHABLE_KEY` in the frontend environment and `CLERK_JWT_ISSUER_DOMAIN` in the Convex backend environment. Confirm values are correct for each deployment environment.",
            "status": "done",
            "testStrategy": "Check that environment variables are loaded and accessible in both frontend and backend during local development and production deployment."
          },
          {
            "id": 3,
            "title": "Integrate Clerk and Convex Providers in Frontend",
            "description": "Implement `ClerkProvider` and `ConvexProviderWithClerk` in the frontend, ensuring correct provider nesting and context propagation.",
            "dependencies": [
              "11.2"
            ],
            "details": "Wrap the application with `ClerkProvider` and then with a client-side wrapper for `ConvexProviderWithClerk`, passing Clerk's `useAuth` hook as required. Ensure provider order and context are correct as per documentation.",
            "status": "done",
            "testStrategy": "Render the application and verify that authentication context is available to all child components. Test login/logout flows and confirm Convex queries/mutations require authentication."
          },
          {
            "id": 4,
            "title": "Implement Authentication Gating in Frontend",
            "description": "Use authentication gating components (`Authenticated`, `Unauthenticated`, `useConvexAuth`) to control access to Convex queries and mutations based on user authentication state.",
            "dependencies": [
              "11.3"
            ],
            "details": "Integrate gating components to restrict access to protected routes and UI elements. Display appropriate UI for authenticated and unauthenticated users.",
            "status": "done",
            "testStrategy": "Test navigation and access control by logging in and out, ensuring protected resources are only accessible to authenticated users."
          },
          {
            "id": 5,
            "title": "Update Convex Functions to Use Clerk Authentication",
            "description": "Refactor all Convex queries, mutations, and actions to use `ctx.auth.getUserIdentity()` for authentication, replacing any legacy Convex authentication logic.",
            "dependencies": [
              "11.1"
            ],
            "details": "Audit all backend functions and update them to check user identity using Clerk JWTs via `ctx.auth.getUserIdentity()`. Remove or replace any deprecated authentication checks.",
            "status": "done",
            "testStrategy": "Invoke queries and mutations with and without valid authentication, confirming correct access control and error handling."
          },
          {
            "id": 6,
            "title": "Remove Legacy Convex Auth Providers and Routes",
            "description": "Clean up the codebase by removing any obsolete Convex Auth HTTP routes or providers that are no longer needed after Clerk integration.",
            "dependencies": [
              "11.5"
            ],
            "details": "Identify and delete legacy authentication code, routes, and configuration files to prevent conflicts and maintain a clean authentication flow.\n<info added on 2025-08-10T21:52:31.870Z>\nCleanup completed:\n- Removed @convex-dev/auth dependency from `packages/backend/package.json`.\n- Removed legacy Google auth envs from `packages/backend/convex/env.ts`.\n- Confirmed no remaining references to `@convex-dev/auth` or `getAuthUserId`.\n\nFollow-ups:\n- Run `bun install` at repo root to refresh lockfile.\n- Verify Convex deploy remains healthy after dependency cleanup.\n\nReference: [Convex & Clerk](https://docs.convex.dev/auth/clerk)\n</info added on 2025-08-10T21:52:31.870Z>",
            "status": "done",
            "testStrategy": "Review the codebase to ensure no legacy authentication logic remains. Run end-to-end tests to confirm the new authentication flow is fully functional."
          }
        ]
      },
      {
        "id": 12,
        "title": "Align Convex User Model with Clerk and Webhooks",
        "description": "Integrate Clerk user management with Convex by maintaining user documents keyed by Clerk ID, adding webhooks, and ensuring user data synchronization.",
        "details": "1. **User Document Management**: Implement a Convex table to store user-specific documents keyed by Clerk's subject ID (clerkId). This table should hold app-specific data such as subscriptions, credits, and user preferences.\n\n2. **Ensure Current User Mutation**: Develop a mutation named `ensureCurrentUserRecord` that upserts a user document upon the first authenticated call using the clerkId. This mutation should be idempotent, ensuring that repeated calls do not create duplicate entries.\n\n3. **Webhook Endpoint for Clerk Events**: Create a Convex httpAction endpoint at `/clerk/webhook` to handle Clerk webhook events, specifically `user.deleted`. This endpoint should delete the corresponding user document in Convex when a user is deleted in Clerk.\n\n4. **Remove Redundant Operations**: Eliminate any existing operations in Convex that duplicate Clerk's profile management, such as image or account deletion. Ensure that these operations are handled via the webhook to maintain consistency.\n\n5. **Data Integrity and Migration**: Ensure that there are no references to legacy Convex Auth tables. Migrate any necessary data to the new users table indexed by clerkId.",
        "testStrategy": "1. **Identity Query Verification**: Test the `whoami` query to ensure it returns the correct identity information based on the Clerk authentication.\n\n2. **Mutation Testing**: Verify that the `ensureCurrentUserRecord` mutation correctly creates a user document when it does not exist and is idempotent upon repeated calls.\n\n3. **Webhook Functionality**: Simulate `user.deleted` events from Clerk and confirm that the `/clerk/webhook` endpoint deletes the corresponding user document in Convex.\n\n4. **Legacy System Check**: Ensure that there are no remaining references to the legacy Convex Auth tables and that all user data is correctly indexed by clerkId.",
        "status": "pending",
        "dependencies": [
          8,
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Convex User Table Keyed by Clerk ID",
            "description": "Implement a Convex table to store user-specific documents keyed by Clerk's subject ID (clerkId). This table should hold app-specific data such as subscriptions, credits, and user preferences.",
            "dependencies": [],
            "details": "Use the Convex schema definition to create a new table named 'users'. Define the primary key as 'clerkId' and include fields for storing user-specific data like subscriptions, credits, and preferences. Ensure the table schema is properly documented and integrated into the existing Convex setup.",
            "status": "pending",
            "testStrategy": "Verify the table creation by checking the Convex dashboard and ensure that the schema matches the requirements. Test inserting and retrieving data using the clerkId as the key."
          },
          {
            "id": 2,
            "title": "Develop ensureCurrentUserRecord Mutation",
            "description": "Create a mutation named `ensureCurrentUserRecord` that upserts a user document upon the first authenticated call using the clerkId. Ensure the mutation is idempotent.",
            "dependencies": [
              "12.1"
            ],
            "details": "Implement the `ensureCurrentUserRecord` mutation in the Convex backend. Use Convex's mutation API to check if a user document exists for the given clerkId. If not, create a new document with default values. Ensure that repeated calls with the same clerkId do not create duplicate entries.",
            "status": "pending",
            "testStrategy": "Test the mutation by calling it with a new clerkId and verify that a new user document is created. Call it again with the same clerkId and ensure no duplicate document is created."
          },
          {
            "id": 3,
            "title": "Implement Clerk Webhook Endpoint for User Deletion",
            "description": "Create a Convex httpAction endpoint at `/clerk/webhook` to handle Clerk webhook events, specifically `user.deleted`. This endpoint should delete the corresponding user document in Convex.",
            "dependencies": [
              "12.1",
              "12.2"
            ],
            "details": "Set up a new HTTP endpoint in the Convex backend to listen for POST requests from Clerk's webhook. Parse the incoming request to extract the clerkId and delete the corresponding user document from the Convex table. Ensure proper authentication and validation of webhook requests.",
            "status": "pending",
            "testStrategy": "Simulate a `user.deleted` event from Clerk and verify that the corresponding user document is removed from the Convex table. Check for proper handling of invalid or unauthorized requests."
          },
          {
            "id": 4,
            "title": "Remove Redundant Convex Operations and Migrate Data",
            "description": "Eliminate any existing operations in Convex that duplicate Clerk's profile management and migrate necessary data to the new users table indexed by clerkId.",
            "dependencies": [
              "12.1",
              "12.2",
              "12.3"
            ],
            "details": "Review the current Convex operations related to user profile management and identify any that are redundant due to Clerk integration. Remove these operations and ensure that all necessary user data is migrated to the new 'users' table. Update any references in the codebase to use the new table structure.",
            "status": "pending",
            "testStrategy": "Verify that all redundant operations are removed and that the system functions correctly with the new user table. Test data migration by checking that all necessary data is present in the new table and accessible via the updated operations."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-10T19:20:11.457Z",
      "updated": "2025-08-12T13:05:48.070Z",
      "description": "Tasks for master context"
    }
  }
}